/**
 * Flowtype definitions for search
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

declare module "N/search" {

declare export var Type: {
    ACCOUNT: "ACCOUNT",
    ACCOUNTING_BOOK: "ACCOUNTING_BOOK",
    ACTIVITY: "ACTIVITY",
    AMORTIZATION_SCHEDULE: "AMORTIZATION_SCHEDULE",
    AMORTIZATION_TEMPLATE: "AMORTIZATION_TEMPLATE",
    ASSEMBLY_BUILD: "ASSEMBLY_BUILD",
    ASSEMBLY_ITEM: "ASSEMBLY_ITEM",
    ASSEMBLY_UNBUILD: "ASSEMBLY_UNBUILD",
    BILLING_ACCOUNT: "BILLING_ACCOUNT",
    BILLING_ACCOUNT_BILL_CYCLE: "BILLING_ACCOUNT_BILL_CYCLE",
    BILLING_CLASS: "BILLING_CLASS",
    BILLING_SCHEDULE: "BILLING_SCHEDULE",
    BIN: "BIN",
    BIN_TRANSFER: "BIN_TRANSFER",
    BIN_WORKSHEET: "BIN_WORKSHEET",
    BLANKET_PURCHASE_ORDER: "BLANKET_PURCHASE_ORDER",
    BUNDLE_INSTALLATION_SCRIPT: "BUNDLE_INSTALLATION_SCRIPT",
    CALENDAR_EVENT: "CALENDAR_EVENT",
    CAMPAIGN: "CAMPAIGN",
    CASH_REFUND: "CASH_REFUND",
    CASH_SALE: "CASH_SALE",
    CHARGE: "CHARGE",
    CHECK: "CHECK",
    CLASSIFICATION: "CLASSIFICATION",
    CLIENT_SCRIPT: "CLIENT_SCRIPT",
    COMPETITOR: "COMPETITOR",
    CONTACT: "CONTACT",
    COUPON_CODE: "COUPON_CODE",
    CREDIT_CARD_CHARGE: "CREDIT_CARD_CHARGE",
    CREDIT_CARD_REFUND: "CREDIT_CARD_REFUND",
    CREDIT_MEMO: "CREDIT_MEMO",
    CURRENCY: "CURRENCY",
    CUSTOMER: "CUSTOMER",
    CUSTOMER_CATEGORY: "CUSTOMER_CATEGORY",
    CUSTOMER_DEPOSIT: "CUSTOMER_DEPOSIT",
    CUSTOMER_PAYMENT: "CUSTOMER_PAYMENT",
    CUSTOMER_REFUND: "CUSTOMER_REFUND",
    CUSTOM_TRANSACTION: "CUSTOM_TRANSACTION",
    DELETED_RECORD: "DELETED_RECORD",
    DEPARTMENT: "DEPARTMENT",
    DEPOSIT: "DEPOSIT",
    DEPOSIT_APPLICATION: "DEPOSIT_APPLICATION",
    DESCRIPTION_ITEM: "DESCRIPTION_ITEM",
    DISCOUNT_ITEM: "DISCOUNT_ITEM",
    DOWNLOAD_ITEM: "DOWNLOAD_ITEM",
    DRIVERS_LICENSE: "DRIVERS_LICENSE",
    EMPLOYEE: "EMPLOYEE",
    END_TO_END_TIME: "END_TO_END_TIME",
    ENTITY: "ENTITY",
    ENTITY_ACCOUNT_MAPPING: "ENTITY_ACCOUNT_MAPPING",
    ESTIMATE: "ESTIMATE",
    EXPENSE_CATEGORY: "EXPENSE_CATEGORY",
    EXPENSE_REPORT: "EXPENSE_REPORT",
    FAIR_VALUE_PRICE: "FAIR_VALUE_PRICE",
    FOLDER: "FOLDER",
    GENERIC_RESOURCE: "GENERIC_RESOURCE",
    GIFT_CERTIFICATE: "GIFT_CERTIFICATE",
    GIFT_CERTIFICATE_ITEM: "GIFT_CERTIFICATE_ITEM",
    GLOBAL_ACCOUNT_MAPPING: "GLOBAL_ACCOUNT_MAPPING",
    GL_LINES_AUDIT_LOG: "GL_LINES_AUDIT_LOG",
    GOVERNMENT_ISSUED_ID_TYPE: "GOVERNMENT_ISSUED_ID_TYPE",
    HCM_JOB: "HCM_JOB",
    INTER_COMPANY_JOURNAL_ENTRY: "INTER_COMPANY_JOURNAL_ENTRY",
    INTER_COMPANY_TRANSFER_ORDER: "INTER_COMPANY_TRANSFER_ORDER",
    INVENTORY_ADJUSTMENT: "INVENTORY_ADJUSTMENT",
    INVENTORY_COST_REVALUATION: "INVENTORY_COST_REVALUATION",
    INVENTORY_COUNT: "INVENTORY_COUNT",
    INVENTORY_DETAIL: "INVENTORY_DETAIL",
    INVENTORY_ITEM: "INVENTORY_ITEM",
    INVENTORY_NUMBER: "INVENTORY_NUMBER",
    INVENTORY_TRANSFER: "INVENTORY_TRANSFER",
    INVOICE: "INVOICE",
    ISSUE: "ISSUE",
    ITEM: "ITEM",
    ITEM_ACCOUNT_MAPPING: "ITEM_ACCOUNT_MAPPING",
    ITEM_DEMAND_PLAN: "ITEM_DEMAND_PLAN",
    ITEM_FULFILLMENT: "ITEM_FULFILLMENT",
    ITEM_GROUP: "ITEM_GROUP",
    ITEM_RECEIPT: "ITEM_RECEIPT",
    ITEM_REVISION: "ITEM_REVISION",
    ITEM_SUPPLY_PLAN: "ITEM_SUPPLY_PLAN",
    JOB: "JOB",
    JOB_REQUISITION: "JOB_REQUISITION",
    JOURNAL_ENTRY: "JOURNAL_ENTRY",
    KIT_ITEM: "KIT_ITEM",
    KUDOS: "KUDOS",
    LEAD: "LEAD",
    LOCATION: "LOCATION",
    LOT_NUMBERED_ASSEMBLY_ITEM: "LOT_NUMBERED_ASSEMBLY_ITEM",
    LOT_NUMBERED_INVENTORY_ITEM: "LOT_NUMBERED_INVENTORY_ITEM",
    MANUFACTURING_COST_TEMPLATE: "MANUFACTURING_COST_TEMPLATE",
    MANUFACTURING_OPERATION_TASK: "MANUFACTURING_OPERATION_TASK",
    MANUFACTURING_ROUTING: "MANUFACTURING_ROUTING",
    MAP_REDUCE_SCRIPT: "MAP_REDUCE_SCRIPT",
    MARKUP_ITEM: "MARKUP_ITEM",
    MASSUPDATE_SCRIPT: "MASSUPDATE_SCRIPT",
    MESSAGE: "MESSAGE",
    MFG_PLANNED_TIME: "MFG_PLANNED_TIME",
    NEXUS: "NEXUS",
    NON_INVENTORY_ITEM: "NON_INVENTORY_ITEM",
    NOTE: "NOTE",
    OPPORTUNITY: "OPPORTUNITY",
    ORGANIZATION_VALUE: "ORGANIZATION_VALUE",
    OTHER_CHARGE_ITEM: "OTHER_CHARGE_ITEM",
    OTHER_GOVERNMENT_ISSUED_ID: "OTHER_GOVERNMENT_ISSUED_ID",
    OTHER_NAME: "OTHER_NAME",
    PARTNER: "PARTNER",
    PASSPORT: "PASSPORT",
    PAYCHECK_JOURNAL: "PAYCHECK_JOURNAL",
    PAYMENT_ITEM: "PAYMENT_ITEM",
    PAYROLL_ITEM: "PAYROLL_ITEM",
    PHONE_CALL: "PHONE_CALL",
    PORTLET: "PORTLET",
    POSITION: "POSITION",
    PRICE_LEVEL: "PRICE_LEVEL",
    PROJECT_EXPENSE_TYPE: "PROJECT_EXPENSE_TYPE",
    PROJECT_TASK: "PROJECT_TASK",
    PROJECT_TEMPLATE: "PROJECT_TEMPLATE",
    PROMOTION_CODE: "PROMOTION_CODE",
    PROSPECT: "PROSPECT",
    PURCHASE_CONTRACT: "PURCHASE_CONTRACT",
    PURCHASE_ORDER: "PURCHASE_ORDER",
    PURCHASE_REQUISITION: "PURCHASE_REQUISITION",
    RATE_PLAN: "RATE_PLAN",
    RECENT_RECORD: "RECENT_RECORD",
    RESOURCE_ALLOCATION: "RESOURCE_ALLOCATION",
    RESTLET: "RESTLET",
    RETURN_AUTHORIZATION: "RETURN_AUTHORIZATION",
    REVENUE_ARRANGEMENT: "REVENUE_ARRANGEMENT",
    REVENUE_COMMITMENT: "REVENUE_COMMITMENT",
    REVENUE_COMMITMENT_REVERSAL: "REVENUE_COMMITMENT_REVERSAL",
    REVENUE_PLAN: "REVENUE_PLAN",
    REV_REC_SCHEDULE: "REV_REC_SCHEDULE",
    REV_REC_TEMPLATE: "REV_REC_TEMPLATE",
    ROLE: "ROLE",
    SALES_ORDER: "SALES_ORDER",
    SALES_TAX_ITEM: "SALES_TAX_ITEM",
    SAVED_SEARCH: "SAVED_SEARCH",
    SCHEDULED_SCRIPT: "SCHEDULED_SCRIPT",
    SCHEDULED_SCRIPT_INSTANCE: "SCHEDULED_SCRIPT_INSTANCE",
    SCRIPT_DEPLOYMENT: "SCRIPT_DEPLOYMENT",
    SERIALIZED_ASSEMBLY_ITEM: "SERIALIZED_ASSEMBLY_ITEM",
    SERIALIZED_INVENTORY_ITEM: "SERIALIZED_INVENTORY_ITEM",
    SERVICE_ITEM: "SERVICE_ITEM",
    SHIP_ITEM: "SHIP_ITEM",
    SOLUTION: "SOLUTION",
    STATISTICAL_JOURNAL_ENTRY: "STATISTICAL_JOURNAL_ENTRY",
    SUBSCRIPTION: "SUBSCRIPTION",
    SUBSCRIPTION_LINE: "SUBSCRIPTION_LINE",
    SUBSCRIPTION_PLAN: "SUBSCRIPTION_PLAN",
    SUBSCRIPTION_RENEWAL_HISTORY: "SUBSCRIPTION_RENEWAL_HISTORY",
    SUBSIDIARY: "SUBSIDIARY",
    SUBTOTAL_ITEM: "SUBTOTAL_ITEM",
    SUITELET: "SUITELET",
    SUITE_SCRIPT_DETAIL: "SUITE_SCRIPT_DETAIL",
    SUPPORT_CASE: "SUPPORT_CASE",
    TASK: "TASK",
    TAX_DETAIL: "TAX_DETAIL",
    TAX_GROUP: "TAX_GROUP",
    TAX_PERIOD: "TAX_PERIOD",
    TAX_TYPE: "TAX_TYPE",
    TERM: "TERM",
    TERMINATION_REASON: "TERMINATION_REASON",
    TIME_BILL: "TIME_BILL",
    TIME_OFF_CHANGE: "TIME_OFF_CHANGE",
    TIME_OFF_PLAN: "TIME_OFF_PLAN",
    TIME_OFF_REQUEST: "TIME_OFF_REQUEST",
    TIME_OFF_RULE: "TIME_OFF_RULE",
    TIME_OFF_TYPE: "TIME_OFF_TYPE",
    TOPIC: "TOPIC",
    TRANSACTION: "TRANSACTION",
    TRANSFER_ORDER: "TRANSFER_ORDER",
    UBER: "UBER",
    UNITS_TYPE: "UNITS_TYPE",
    USEREVENT_SCRIPT: "USEREVENT_SCRIPT",
    VENDOR: "VENDOR",
    VENDOR_BILL: "VENDOR_BILL",
    VENDOR_CATEGORY: "VENDOR_CATEGORY",
    VENDOR_CREDIT: "VENDOR_CREDIT",
    VENDOR_PAYMENT: "VENDOR_PAYMENT",
    VENDOR_RETURN_AUTHORIZATION: "VENDOR_RETURN_AUTHORIZATION",
    WORKFLOW_ACTION_SCRIPT: "WORKFLOW_ACTION_SCRIPT",
    WORK_ORDER: "WORK_ORDER",
    WORK_ORDER_CLOSE: "WORK_ORDER_CLOSE",
    WORK_ORDER_COMPLETION: "WORK_ORDER_COMPLETION",
    WORK_ORDER_ISSUE: "WORK_ORDER_ISSUE",
    W_S_LOG: "W_S_LOG",
}

declare export type TypeT = $Values<typeof Type>

declare export var Operator: {
    AFTER: "AFTER",
    ALLOF: "ALLOF",
    ANY: "ANY",
    ANYOF: "ANYOF",
    BEFORE: "BEFORE",
    BETWEEN: "BETWEEN",
    CONTAINS: "CONTAINS",
    DOESNOTCONTAIN: "DOESNOTCONTAIN",
    DOESNOTSTARTWITH: "DOESNOTSTARTWITH",
    EQUALTO: "EQUALTO",
    GREATERTHAN: "GREATERTHAN",
    GREATERTHANOREQUALTO: "GREATERTHANOREQUALTO",
    HASKEYWORDS: "HASKEYWORDS",
    IS: "IS",
    ISEMPTY: "ISEMPTY",
    ISNOT: "ISNOT",
    ISNOTEMPTY: "ISNOTEMPTY",
    LESSTHAN: "LESSTHAN",
    LESSTHANOREQUALTO: "LESSTHANOREQUALTO",
    NONEOF: "NONEOF",
    NOTAFTER: "NOTAFTER",
    NOTALLOF: "NOTALLOF",
    NOTBEFORE: "NOTBEFORE",
    NOTBETWEEN: "NOTBETWEEN",
    NOTEQUALTO: "NOTEQUALTO",
    NOTGREATERTHAN: "NOTGREATERTHAN",
    NOTGREATERTHANOREQUALTO: "NOTGREATERTHANOREQUALTO",
    NOTLESSTHAN: "NOTLESSTHAN",
    NOTLESSTHANOREQUALTO: "NOTLESSTHANOREQUALTO",
    NOTON: "NOTON",
    NOTONORAFTER: "NOTONORAFTER",
    NOTONORBEFORE: "NOTONORBEFORE",
    NOTWITHIN: "NOTWITHIN",
    ON: "ON",
    ONORAFTER: "ONORAFTER",
    ONORBEFORE: "ONORBEFORE",
    STARTSWITH: "STARTSWITH",
    WITHIN: "WITHIN",
}

declare export type OperatorT = $Values<typeof Operator>

declare export var Summary: {
    GROUP: "GROUP",
    COUNT: "COUNT",
    SUM: "SUM",
    AVG: "AVG",
    MIN: "MIN",
    MAX: "MAX",
}

declare type SummaryT = $Values<typeof Summary>

declare export var Sort: {
    ASC: "ASC",
    DESC: "DESC",
    NONE: "NONE",
}

declare type SortT = $Values<typeof Sort>
  
/**
 * Encapsulates a search filter used in a search. Use the properties for the Filter object to get and set the filter properties. 
 */
declare export interface Filter {

    /**
     * Name or internal ID of the search field as a string. 
     */
    name: string,

        /**
         * Join ID for the search filter as a string. 
         */
        join: string,

        /**
         * Operator used for the search filter. See search.Operator. 
         */
        operator: OperatorT,

        /**
         * Summary type for the search filter. Use this property to get or set the value of the summary type. See search.Summary. 
         */
        summary: SummaryT,

        /**
         * Formula used by the search filter. Use this property to get or set the formula used by the search filter. 
         */
        formula: string
}
declare interface SearchColumnSetWhenOrderedByOptions {

    /**
     * The name of the search column for which the minimal or maximal value should be found. 
     */
    name: string,

        /**
         * The join id for the search column. 
         */
        join: string
}
/**
 * Encapsulates a single search column in a search.Search. Use the methods and properties available to the Column object to get or set Column properties. 
 */
declare export interface Column {

    /**
     * Returns the search column for which the minimal or maximal value should be found when returning the search.Column value. 
     */
    setWhenOrderedBy(options: SearchColumnSetWhenOrderedByOptions): Column,

        /**
         * Name of a search column as a string. 
         */
        name: string,

        /**
         * Join ID for a search column as a string. 
         */
        join?: string,

        /**
         * Returns the summary type for a search column. 
         */
        summary?: SummaryT,

        /**
         * Formula used for a search column as a string. To set this value, you must use formulatext, formulanumeric, formuladatetime, formulapercent, or formulacurrency. 
         */
        formula?: string,

        /**
         * Label used for the search column. You can only get or set custom labels with this property. 
         */
        label?: string,

        /**
         * Special function applied to values in a search column. See Help for Supported Functions. 
         */
        function?: string,

        /**
         * The sort order of the column. Use the search.Sort enum to set the value. 
         */
        sort?: SortT
}
declare interface SearchResultGetValueTextOptions {
    name: string,
        join?: string,
        summary?: SummaryT
}
declare export interface Result {
    getValue(column: Column | string): boolean | string | string[],
        getText(options: Column | string): string,
        recordType: TypeT | string,
        id: string,
        columns: Column[]
}
declare interface SearchResultSetGetRangeOptions {
    start: number,
        end: number
}
declare interface SearchResultSetGetRangeFunction {
    promise(options: SearchResultSetGetRangeOptions): Promise<Result[]>,
  (options: SearchResultSetGetRangeOptions): Result[],
  (start: number, end: number): Result[]
}
declare interface SearchResultSetEachFunction {
    promise(callback: (result: Result, index: number) => boolean): Promise<boolean>,
        (callback: (result: Result, index: number) => boolean): void
}
declare export interface ResultSet {
    each: SearchResultSetEachFunction,
        getRange: SearchResultSetGetRangeFunction,
        columns: Column[]
}
declare interface FetchOptions {

    /**
     * The index of the page range that bounds the desired data.
     */
    index: number
}
declare interface PageNextFunction {
    promise(): Promise<Page>,
        (): Page
}
declare interface PagePrevFunction {
    promise(): Promise<Page>,
        (): Page
}
declare interface PagedDataFetchFunction {
    promise(options: FetchOptions): Promise<Page>,
        (options: FetchOptions): Page
}
declare export interface Page {
    next: PageNextFunction,
        prev: PagePrevFunction,
        data: Result[],
        isFirst: boolean,
        isLast: boolean,
        pagedData: PagedData,
        pagedRange: PageRange
}
declare export interface PageRange {
    compoundLabel: string,
        index: number
}
declare export interface PagedData {
    fetch: PagedDataFetchFunction,
        count: number,
        pageRanges: PageRange[],
        pageSize: number,
        searchDefinition: Search
}
declare interface RunPagedOptions {

    /**
     * Maximum number of entries per page.
     * There is an upper limit, a lower limit, and a default setting:
    - The maximum number allowed is 1000.
    - The minimum number allowed is 5.
    - By default, the page size is set to 50 entries per page.
    */
    pageSize?: number
}
declare interface SearchRunPagedFunction {
    promise(options?: RunPagedOptions): Promise<PagedData>,
        (options?: RunPagedOptions): PagedData
}
declare export interface Search {
    searchType: TypeT | string,
        searchId: number,
        filters: Filter[],
        filterExpression: any[],
        columns: (Column[] | string[]),
        title: string,
        id: string,
        isPublic: boolean,
        save(): number,
        run(): ResultSet,
        runPaged: SearchRunPagedFunction
}
declare interface CreateSearchFilterOptions {
    name: string,
        join?: string,
        operator: OperatorT,
        values?: (string | Date | number | string[]),
        formula?: string,
        summary?: SummaryT
}
declare interface CreateSearchColumnOptions {
    name: string,
        join?: string,
        summary?: SummaryT,
        formula?: string,
        function?: string,
        label?: string,
        sort?: SortT
}
declare interface SearchLookupFieldsOptions {
    type: TypeT | string,
        id: string,
        columns: (string | string[])
}
declare interface SearchLookupFieldsFunction {
    promise(options: SearchLookupFieldsOptions): Promise<any>,
        (options: SearchLookupFieldsOptions): any
}
declare interface SearchGlobalOptions {
    keywords: string
}
declare interface SearchGlobalFunction {
    promise(options: SearchGlobalOptions): Promise<Result[]>,
        (options: SearchGlobalOptions): Result[]
}
declare interface SearchDuplicatesOptions {
    type: TypeT | string,
        fields?: string[],
        id?: number
}
declare interface SearchDuplicatesFunction {
    promise(options: SearchDuplicatesOptions): Promise<Result[]>,
        (options: SearchDuplicatesOptions): Result[]
}
declare interface SearchDeleteOptions {
    id: string
}
declare interface SearchDeleteFunction {
    promise(options: SearchDeleteOptions): Promise<void>,
        (options: SearchDeleteOptions): void
}
declare interface SearchLoadOptions {
    id: string
}
declare interface SearchLoadFunction {
    promise(options: SearchLoadOptions): Promise<Search>,
        (options: SearchLoadOptions): Search
}

declare type FilterExpression = [string, OperatorT, any] | 'and' | 'or' | 'not' | FilterExpression;
declare interface SearchCreateOptions {
    type: TypeT | string,
  filters?: (Filter | (Filter | FilterExpression)[] /*  | FilterExpression // but this causes the type inference to fail */),
        filterExpression?: FilterExpression[],
        columns?: (Array<Column | string>),
        title?: string,
        id?: string,
        isPublic?: boolean
}
declare interface SearchCreateFunction {
    (options: SearchCreateOptions): Search,
    promise(options: SearchCreateOptions): Promise<Search >
}
declare export var create: SearchCreateFunction;
declare export var load: SearchLoadFunction;
declare var deleteFunc: SearchDeleteFunction;
declare export var duplicates: SearchDuplicatesFunction;
declare export var global: SearchGlobalFunction;
declare export var lookupFields: SearchLookupFieldsFunction;
declare export function createColumn(options: CreateSearchColumnOptions): Column
declare export function createFilter(options: CreateSearchFilterOptions): Filter

}
