/**
 * Flowtype definitions for types
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

import type {ServerRequest, ServerResponse} from 'N/http';
import type {Portlet} from 'N/portlet';
import type {ClientCurrentRecord, Record} from 'N/record';
import type {Search} from 'N/search';
import type {Form} from 'N/ui/serverWidget';

declare module "N/types" {

declare function define(moduleNames: Array<string>, builder: (...modules: Array<{}>) => void): {};

/*
Don't export these into the Namespace as we don't
want to accidentally use a comparison like this:
export var beforeSubmit: EntryPoints.UserEvent.beforeSubmit = (ctx) => {
    //THIS IS WRONG
    if(ctx.Type == EntryPoints.UserEvent.Type.EDIT) {
        ...
    }
};
*/
declare export var UserEventType: {
    APPROVE: "APPROVE",
    CANCEL: "CANCEL",
    CHANGEPASSWORD: "CHANGEPASSWORD",
    COPY: "COPY",
    CREATE: "CREATE",
    DELETE: "DELETE",
    DROPSHIP: "DROPSHIP",
    EDIT: "EDIT",
    EDITFORECAST: "EDITFORECAST",
    EMAIL: "EMAIL",
    MARKCOMPLETE: "MARKCOMPLETE",
    ORDERITEMS: "ORDERITEMS",
    PACK: "PACK",
    PAYBILLS: "PAYBILLS",
    PRINT: "PRINT",
    QUICKVIEW: "QUICKVIEW",
    REASSIGN: "REASSIGN",
    REJECT: "REJECT",
    SHIP: "SHIP",
    SPECIALORDER: "SPECIALORDER",
    TRANSFORM: "TRANSFORM",
    VIEW: "VIEW",
    XEDIT: "XEDIT",
}

declare export type UserEventTypeT = $Values<typeof UserEventType>

declare interface UserEventTypes {
    APPROVE: UserEventTypeT,
        CANCEL: UserEventTypeT,
        CHANGEPASSWORD: UserEventTypeT,
        COPY: UserEventTypeT,
        CREATE: UserEventTypeT,
        DELETE: UserEventTypeT,
        DROPSHIP: UserEventTypeT,
        EDIT: UserEventTypeT,
        EDITFORECAST: UserEventTypeT,
        EMAIL: UserEventTypeT,
        MARKCOMPLETE: UserEventTypeT,
        ORDERITEMS: UserEventTypeT,
        PACK: UserEventTypeT,
        PAYBILLS: UserEventTypeT,
        PRINT: UserEventTypeT,
        QUICKVIEW: UserEventTypeT,
        REASSIGN: UserEventTypeT,
        REJECT: UserEventTypeT,
        SHIP: UserEventTypeT,
        SPECIALORDER: UserEventTypeT,
        TRANSFORM: UserEventTypeT,
        VIEW: UserEventTypeT,
        XEDIT: UserEventTypeT
}

declare var ScheduledInvocationType: {
    SCHEDULED: "SCHEDULED",
    ON_DEMAND: "ON_DEMAND",
    USER: "USER",
    ABORTED: "ABORTED",
    SKIPPED: "SKIPPED",
}

declare type ScheduledInvocationTypeT = $Values<typeof ScheduledInvocationType>

declare interface ScheduledInvocationTypes {
    SCHEDULED: ScheduledInvocationTypeT,
        ON_DEMAND: ScheduledInvocationTypeT,
        USER: ScheduledInvocationTypeT,
        ABORTED: ScheduledInvocationTypeT,
        SKIPPED: ScheduledInvocationTypeT
}
declare interface Client$fieldChangedContext {
    currentRecord: ClientCurrentRecord,
        sublistId: string,
        fieldId: string,
        line: number,
        column: number
}

declare type Client$fieldChanged = (scriptContext?: Client$fieldChangedContext) => void;

declare interface Client$lineInitContext {
    currentRecord: ClientCurrentRecord,
        sublistId: string
}

declare type Client$lineInit = (scriptContext?: Client$lineInitContext) => void;

declare interface Client$pageInitContext {
    currentRecord: ClientCurrentRecord,
        mode: string
}

declare type Client$pageInit = (scriptContext?: Client$pageInitContext) => void;

declare interface Client$postSourcingContext {
    currentRecord: ClientCurrentRecord,
        sublistId: string,
        fieldId: string
}

declare type Client$postSourcing = (scriptContext?: Client$postSourcingContext) => void;

declare interface Client$saveRecordContext {
    currentRecord: ClientCurrentRecord
}

declare type Client$saveRecord = (scriptContext?: Client$saveRecordContext) => boolean;

declare interface Client$sublistChangedContext {
    currentRecord: ClientCurrentRecord,
        sublistId: string,

        /**
         * Commit, etc.
         */
        operation: string
}

declare type Client$sublistChanged = (scriptContext?: Client$sublistChangedContext) => void;

declare interface Client$validateDeleteContext {
    currentRecord: ClientCurrentRecord,
        sublistId: string
}

declare type Client$validateDelete = (scriptContext?: Client$validateDeleteContext) => boolean;

declare interface Client$validateFieldContext {
    currentRecord: ClientCurrentRecord,
        sublistId: string,
        fieldId: string,
        line?: number,
        column?: number
}

declare type Client$validateField = (scriptContext?: Client$validateFieldContext) => boolean;

declare interface Client$validateInsertContext {
    currentRecord: ClientCurrentRecord,
        sublistId: string
}

declare type Client$validateInsert = (scriptContext?: Client$validateInsertContext) => boolean;

declare interface Client$validateLineContext {
    currentRecord: ClientCurrentRecord,
        sublistId: string
}

declare type Client$validateLine = (scriptContext?: Client$validateLineContext) => boolean;

declare interface UserEvent$beforeLoadContext {
    newRecord: Record,
        form: Form,
        type: UserEventTypeT,
        UserEventType: UserEventTypes,
        request: ServerRequest
}

declare type UserEvent$beforeLoad = (scriptContext?: UserEvent$beforeLoadContext) => void;

declare interface UserEvent$beforeSubmitContext {
    newRecord: Record,
        oldRecord: Record,
        type: UserEventTypeT,
        UserEventType: UserEventTypes
}

declare type UserEvent$beforeSubmit = (scriptContext?: UserEvent$beforeSubmitContext) => void;

declare interface UserEvent$afterSubmitContext {
    newRecord: Record,
        oldRecord: Record,
        type: UserEventTypeT,
        UserEventType: UserEventTypes
}

declare type UserEvent$afterSubmit = (scriptContext?: UserEvent$afterSubmitContext) => void;

declare interface Scheduled$executeContext {
    type: ScheduledInvocationTypeT,
        InvocationType: ScheduledInvocationTypes
}

declare type Scheduled$execute = (scriptContext?: Scheduled$executeContext) => void;

declare interface MapReduce$ObjectReference {
    id: string,
        type: string
}

declare interface MapReduce$getInputDataContext {
    isRestarted: boolean,
        ObjectRef: MapReduce$ObjectReference
}

declare export type MapReduce$getInputData = (
    scriptContext: MapReduce$getInputDataContext) => Search | any | any[] | MapReduce$ObjectReference;

declare interface MapReduce$mapContext {
    isRestarted: boolean,
        key: string,
        value: string,
        write: (key: string, value: any) => void
}

declare export type MapReduce$map = (scriptContext: MapReduce$mapContext) => void;

declare interface MapReduce$reduceContext {
    isRestarted: boolean,
        key: string,
        values: string[],
        write: (key: string, value: any) => void
}

declare export type MapReduce$reduce = (scriptContext: MapReduce$reduceContext) => void;

declare interface MapReduce$MapReduceIterator {
    each(callback: (key: string, value: string) => boolean): void
}

declare interface MapReduce$MapReduceIteratorContainer {
    iterator(): MapReduce$MapReduceIterator
}

declare interface MapReduce$InputSummary {
    dateCreated: Date,
        error: string,
        seconds: number,
        usage: number
}

declare interface MapReduce$MapSummary {
    dateCreated: Date,
        seconds: number,
        usage: number,
        concurrency: number,
        yields: number,
        keys: MapReduce$MapReduceIteratorContainer,
        errors: MapReduce$MapReduceIteratorContainer
}

declare interface MapReduce$ReduceSummary {
    dateCreated: Date,
        seconds: number,
        usage: number,
        concurrency: number,
        yields: number,
        keys: MapReduce$MapReduceIteratorContainer,
        errors: MapReduce$MapReduceIteratorContainer
}

declare interface MapReduce$summarizeContext {
    isRestarted: boolean,
        dateCreated: Date,
        seconds: number,
        usage: number,
        concurrency: number,
        yields: number,
        inputSummary: MapReduce$InputSummary,
        mapSummary: MapReduce$MapSummary,
        reduceSummary: MapReduce$ReduceSummary,
        output: MapReduce$MapReduceIteratorContainer
}

declare export type MapReduce$summarize = (summary: MapReduce$summarizeContext) => void;

declare interface Portlet$renderContext {
    portlet: Portlet,
        column: number,
        entityid: string
}

declare type Portlet$render = (scriptContext?: Portlet$renderContext) => void;

declare interface Suitelet$onRequestContext {
    request: ServerRequest,
        response: ServerResponse
}

declare type Suitelet$onRequest = (scriptContext?: Suitelet$onRequestContext) => void;

declare interface MassUpdate$eachContext {
    id: number,
        type: string
}

declare type MassUpdate$each = (scriptContext?: MassUpdate$eachContext) => void;

declare interface WorkflowAction$onActionContext {
    newRecord: Record,
        oldRecord: Record
}

declare type WorkflowAction$onAction = (scriptContext?: WorkflowAction$onActionContext) => void;

declare type RESTlet$get = (requestParams?: any) => any;

declare type RESTlet$delete_ = (requestParams?: any) => any;

declare type RESTlet$post = (requestBody?: any) => any;

declare type RESTlet$put = (requestBody?: any) => any;

declare interface BundleInstallation$onAfterInstallParms {
    version: number
}

declare type BundleInstallation$afterInstall = (parms?: BundleInstallation$onAfterInstallParms) => void;

declare interface BundleInstallation$onAfterUpdateParms {
    fromVersion: number,
        toVersion: number
}

declare type BundleInstallation$afterUpdate = (parms?: BundleInstallation$onAfterUpdateParms) => void;

declare interface BundleInstallation$onBeforeInstallParms {
    version: number
}

declare type BundleInstallation$BeforeInstall = (parms?: BundleInstallation$onBeforeInstallParms) => void;

declare interface BundleInstallation$onBeforeUninstallParms {
    version: number
}

declare type BundleInstallation$beforeUninstall = (parms?: BundleInstallation$onBeforeUninstallParms) => void;

declare interface BundleInstallation$onBeforeUpdateParms {
    fromVersion: number,
        toVersion: number
}

declare type BundleInstallation$beforeUpdate = (parms?: BundleInstallation$onBeforeUpdateParms) => void;

}
